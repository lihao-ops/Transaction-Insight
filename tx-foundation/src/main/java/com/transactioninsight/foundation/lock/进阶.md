# 🎯 大厂面试进阶 - 让面试官眼前一亮的深度知识

掌握前面的7个场景是**基础**，但要在大厂面试中脱颖而出，你还需要掌握以下**进阶知识点**和**实战经验**。

---

## 💎 Level 1: 基础掌握（你已经完成）

✅ 知道什么是行锁、表锁、间隙锁  
✅ 理解MVCC和锁的关系  
✅ 能复现死锁和幻读

**面试评价**：及格，但不够亮眼

---

## 🚀 Level 2: 深度理解（让面试官刮目相看）

### 1. 锁的底层实现原理

#### 面试官会问：
> "InnoDB的行锁是怎么实现的？为什么没有索引会升级为表锁？"

**标准答案：**
```
InnoDB的行锁实际上是锁在索引记录上的：

1. 如果查询条件命中索引：
   - 只锁定匹配的索引记录
   - 行锁生效，并发度高

2. 如果查询条件没有索引：
   - InnoDB会扫描全表（表扫描）
   - 每扫描一行就加锁，最终锁住整个表
   - 实际上是"行锁的全覆盖" = 表锁效果

3. 为什么这样设计？
   - InnoDB没有单独的表锁机制（除了DDL）
   - 所有锁都是加在索引树上
   - 无索引 = 必须扫描聚簇索引 = 锁所有行
```

**测试验证代码：**
```java
// 无索引的更新 - 会锁全表
@Test
public void testNoIndexLock() {
    // 假设balance字段没有索引
    @Transactional
    public void updateWithoutIndex() {
        // 这条SQL会锁住整个表！
        entityManager.createQuery(
            "UPDATE Account a SET a.balance = a.balance + 100 WHERE a.balance > 500"
        ).executeUpdate();
    }
}

// 有索引的更新 - 只锁匹配行
@Test
public void testWithIndexLock() {
    // accountNo有索引
    @Transactional
    public void updateWithIndex() {
        // 只锁定account_no='ACC001'这一行
        Account acc = accountRepository
            .findByAccountNoWithExclusiveLock("ACC001")
            .orElseThrow();
        acc.setBalance(acc.getBalance().add(new BigDecimal("100")));
    }
}
```

---

### 2. 临键锁(Next-Key Lock)的精确范围

#### 面试官会问：
> "间隙锁的具体范围是怎么确定的？临键锁和间隙锁有什么区别？"

**核心概念：**
```
Record Lock (记录锁): 锁定具体的索引记录
Gap Lock (间隙锁):   锁定索引记录之间的间隙
Next-Key Lock:      = Record Lock + Gap Lock (左开右闭)

示例：
假设索引值为: 10, 20, 30

SELECT * FROM t WHERE id > 15 FOR UPDATE;

会产生的锁：
- (10, 20]  ← 临键锁：锁住间隙(10,20)和记录20
- (20, 30]  ← 临键锁
- (30, +∞)  ← 间隙锁（最后一个记录后的间隙）
```

**测试代码：**
```java
@Test
public void testNextKeyLockRange() throws InterruptedException {
    // 准备数据：id为10, 20, 30
    prepareData();
    
    CountDownLatch latch = new CountDownLatch(2);
    
    // 事务1：查询id > 15
    new Thread(() -> {
        transactionTemplate.execute(status -> {
            log.info("[T1] 执行：SELECT * FROM account WHERE id > 15 FOR UPDATE");
            List<Account> list = entityManager
                .createQuery("SELECT a FROM Account a WHERE a.id > 15", Account.class)
                .setLockMode(LockModeType.PESSIMISTIC_WRITE)
                .getResultList();
            
            log.info("[T1] 锁定范围：(10,20], (20,30], (30,+∞)");
            
            try {
                Thread.sleep(5000); // 持有锁5秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            latch.countDown();
            return null;
        });
    }).start();
    
    Thread.sleep(500);
    
    // 事务2：尝试插入不同位置的数据
    new Thread(() -> {
        // 尝试1: 插入id=11（在间隙(10,20)内）
        log.info("[T2] 尝试插入id=11...");
        try {
            insertAccount(11L); // 会被阻塞！
            log.info("[T2] id=11 插入成功");
        } catch (Exception e) {
            log.error("[T2] id=11 插入失败: {}", e.getMessage());
        }
        
        // 尝试2: 插入id=9（在间隙外，10之前）
        log.info("[T2] 尝试插入id=9...");
        try {
            insertAccount(9L); // 可以成功！
            log.info("[T2] id=9 插入成功");
        } catch (Exception e) {
            log.error("[T2] id=9 插入失败: {}", e.getMessage());
        }
        
        latch.countDown();
    }).start();
    
    latch.await();
}
```

---

### 3. 死锁的避免策略

#### 面试官会问：
> "在实际项目中，你是如何避免死锁的？遇到过死锁怎么解决？"

**最佳实践答案：**

```java
/**
 * 策略1：统一加锁顺序（最重要！）
 * 
 * 错误示例：
 * T1: 锁A -> 锁B
 * T2: 锁B -> 锁A  ← 可能死锁
 * 
 * 正确示例：
 * T1: 锁A -> 锁B
 * T2: 锁A -> 锁B  ← 不会死锁
 */
@Service
public class TransferService {
    
    // ❌ 错误：直接按参数顺序加锁
    public void transferWrong(String fromAccount, String toAccount, BigDecimal amount) {
        Account from = lockAccount(fromAccount);
        Account to = lockAccount(toAccount);
        // ... 转账逻辑
    }
    
    // ✅ 正确：按账户号排序后加锁
    @Transactional
    public void transferCorrect(String fromAccount, String toAccount, BigDecimal amount) {
        // 1. 排序：确保始终按相同顺序加锁
        List<String> accounts = Arrays.asList(fromAccount, toAccount);
        Collections.sort(accounts);
        
        // 2. 按顺序加锁
        Account acc1 = lockAccount(accounts.get(0));
        Account acc2 = lockAccount(accounts.get(1));
        
        // 3. 判断谁是from，谁是to
        Account from = acc1.getAccountNo().equals(fromAccount) ? acc1 : acc2;
        Account to = acc1.getAccountNo().equals(toAccount) ? acc1 : acc2;
        
        // 4. 执行转账
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
        
        log.info("转账成功：{} -> {}, 金额: {}", fromAccount, toAccount, amount);
    }
    
    private Account lockAccount(String accountNo) {
        return accountRepository
            .findByAccountNoWithExclusiveLock(accountNo)
            .orElseThrow(() -> new RuntimeException("账户不存在"));
    }
}

/**
 * 策略2：缩短事务时间
 */
@Transactional
public void processOrderBad() {
    Order order = lockOrder(orderId); // 加锁
    
    // ❌ 错误：在事务内做耗时操作
    sendEmail(order);        // 发邮件：2秒
    callThirdPartyAPI(order); // 调用外部API：3秒
    
    order.setStatus("COMPLETED");
    // 持有锁5秒！
}

@Transactional
public void processOrderGood() {
    Order order = lockOrder(orderId); // 加锁
    order.setStatus("COMPLETED");
    // 快速释放锁（0.1秒）
}
// ✅ 正确：事务外做耗时操作
public void afterCommit(Order order) {
    sendEmail(order);
    callThirdPartyAPI(order);
}

/**
 * 策略3：设置锁超时时间
 */
// application.yml
spring:
  jpa:
    properties:
      javax.persistence.lock.timeout: 5000  # 5秒超时
      
// MySQL全局设置
SET GLOBAL innodb_lock_wait_timeout = 5;

/**
 * 策略4：捕获死锁并重试
 */
@Service
public class RetryableTransferService {
    
    private static final int MAX_RETRIES = 3;
    
    public void transferWithRetry(String from, String to, BigDecimal amount) {
        int retryCount = 0;
        
        while (retryCount < MAX_RETRIES) {
            try {
                transferCorrect(from, to, amount);
                return; // 成功
                
            } catch (Exception e) {
                if (isDeadlock(e)) {
                    retryCount++;
                    log.warn("死锁发生，第{}次重试", retryCount);
                    
                    if (retryCount >= MAX_RETRIES) {
                        throw new RuntimeException("转账失败：多次重试后仍然死锁", e);
                    }
                    
                    // 随机延迟后重试，避免再次冲突
                    try {
                        Thread.sleep(new Random().nextInt(100));
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                    }
                } else {
                    throw e; // 其他异常直接抛出
                }
            }
        }
    }
    
    private boolean isDeadlock(Exception e) {
        return e.getMessage() != null && 
               e.getMessage().contains("Deadlock found");
    }
}
```

---

### 4. 乐观锁的ABA问题

#### 面试官会问：
> "乐观锁的version字段能解决所有问题吗？什么是ABA问题？"

**核心问题：**
```
时间线：
T1: 读取 balance=100, version=1
T2: 读取 balance=100, version=1
T2: 修改 balance=200, version=2  (提交)
T3: 修改 balance=100, version=3  (提交) ← 余额恢复到100！
T1: 比较version=1，发现已经是version=3，更新失败

问题：
虽然version能检测到数据被修改过，
但T1无法知道数据经历了 100->200->100 的变化
```

**解决方案：**
```java
/**
 * 方案1：记录修改历史
 */
@Entity
@Table(name = "account_history")
public class AccountHistory {
    @Id
    @GeneratedValue
    private Long id;
    
    private Long accountId;
    private BigDecimal oldBalance;
    private BigDecimal newBalance;
    private LocalDateTime changeTime;
    private String operator;
}

/**
 * 方案2：使用CAS + 值比较（而不只是version）
 */
@Transactional
public boolean updateBalanceCAS(Long accountId, 
                                 BigDecimal expectedBalance, 
                                 BigDecimal newBalance) {
    int updated = entityManager.createQuery(
        "UPDATE Account a SET a.balance = :newBalance, a.version = a.version + 1 " +
        "WHERE a.id = :id AND a.balance = :expectedBalance"
    )
    .setParameter("id", accountId)
    .setParameter("expectedBalance", expectedBalance)
    .setParameter("newBalance", newBalance)
    .executeUpdate();
    
    return updated > 0;
}

/**
 * 方案3：使用状态机（最推荐）
 */
@Entity
public class Order {
    @Id
    private Long id;
    
    @Enumerated(EnumType.STRING)
    private OrderStatus status; // CREATED -> PAID -> SHIPPED -> COMPLETED
    
    @Version
    private Long version;
}

@Service
public class OrderService {
    
    // ✅ 状态机：只能从CREATED变为PAID
    @Transactional
    public void payOrder(Long orderId) {
        Order order = orderRepository.findById(orderId).orElseThrow();
        
        if (order.getStatus() != OrderStatus.CREATED) {
            throw new IllegalStateException(
                "只有CREATED状态的订单才能支付，当前状态：" + order.getStatus()
            );
        }
        
        order.setStatus(OrderStatus.PAID);
        // 即使version被修改，状态检查也能防止错误操作
    }
}
```

---

### 5. 分布式锁与数据库锁的对比

#### 面试官会问：
> "为什么有了数据库锁，还需要Redis分布式锁？"

**对比分析：**

| 维度 | 数据库锁 | Redis分布式锁 |
|------|----------|---------------|
| **性能** | 较慢（涉及磁盘IO） | 快（内存操作） |
| **适用范围** | 单个数据库实例 | 跨服务、跨数据库 |
| **锁粒度** | 表/行级别 | 任意业务逻辑 |
| **持久性** | 强（事务保证） | 弱（可能丢失） |
| **死锁检测** | 自动检测 | 需要手动实现 |
| **适用场景** | 数据一致性要求高 | 高并发、跨服务 |

**实战选择：**
```java
/**
 * 场景1：扣减库存 - 用数据库锁
 * 原因：必须保证数据一致性，库存不能超卖
 */
@Transactional
public void deductStock(Long productId, Integer quantity) {
    Product product = productRepository
        .findByIdWithLock(productId)  // SELECT ... FOR UPDATE
        .orElseThrow();
    
    if (product.getStock() < quantity) {
        throw new RuntimeException("库存不足");
    }
    
    product.setStock(product.getStock() - quantity);
    // 数据库锁保证：即使高并发，库存也不会为负
}

/**
 * 场景2：秒杀活动 - 用Redis分布式锁
 * 原因：10万QPS，数据库扛不住，用Redis削峰
 */
@Service
public class SeckillService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public boolean seckill(Long userId, Long productId) {
        String lockKey = "seckill:" + productId;
        
        // 1. Redis分布式锁削峰
        Boolean acquired = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, String.valueOf(userId), 10, TimeUnit.SECONDS);
        
        if (Boolean.FALSE.equals(acquired)) {
            return false; // 抢锁失败，快速返回
        }
        
        try {
            // 2. 检查Redis中的库存（缓存）
            Long stock = redisTemplate.opsForValue()
                .decrement("stock:" + productId);
            
            if (stock == null || stock < 0) {
                return false; // 库存不足
            }
            
            // 3. 异步写入数据库（最终一致性）
            asyncDeductStock(productId, 1);
            
            return true;
            
        } finally {
            redisTemplate.delete(lockKey);
        }
    }
}

/**
 * 场景3：分布式定时任务 - 用数据库锁
 * 原因：天然的分布式协调，避免重复执行
 */
@Entity
@Table(name = "scheduled_lock")
public class ScheduledLock {
    @Id
    private String lockName;
    private LocalDateTime lockTime;
    private String lockOwner;
}

@Service
public class DistributedScheduler {
    
    @Transactional
    public boolean tryLock(String taskName) {
        try {
            ScheduledLock lock = new ScheduledLock();
            lock.setLockName(taskName);
            lock.setLockTime(LocalDateTime.now());
            lock.setLockOwner(getHostName());
            
            lockRepository.save(lock); // 唯一索引保证只有一个实例能成功
            return true;
            
        } catch (DataIntegrityViolationException e) {
            return false; // 其他实例已经获取锁
        }
    }
}
```

---

## 🔥 Level 3: 实战经验（让面试官认为你是专家）

### 1. 线上故障案例

**案例：某电商平台订单系统死锁事故**

```
背景：
- 双11活动，订单量暴增
- 频繁出现死锁，导致订单创建失败
- 用户投诉激增

原因分析：
CREATE TABLE `order` (
    id BIGINT PRIMARY KEY,
    user_id BIGINT,
    product_id BIGINT,
    INDEX idx_user (user_id),
    INDEX idx_product (product_id)
);

问题代码：
@Transactional
public void createOrder(Long userId, Long productId) {
    // T1: WHERE user_id = 100   锁住user_id=100的所有订单
    // T2: WHERE product_id = 200 锁住product_id=200的所有订单
    
    List<Order> userOrders = orderRepository.findByUserId(userId);     // 锁1
    List<Order> productOrders = orderRepository.findByProductId(productId); // 锁2
    
    // 如果：
    // T1锁住user=100的订单（包括订单A：user=100, product=200）
    // T2锁住product=200的订单（包括订单A）
    // 互相等待 -> 死锁！
}

解决方案：
1. 优化查询：不需要查询历史订单，直接插入新订单
2. 避免范围锁：使用精确的主键查询
3. 分离读写：读操作用从库，写操作用主库

优化后代码：
@Transactional
public void createOrderOptimized(Long userId, Long productId) {
    // 1. 检查库存（不加锁）
    Product product = productRepository.findById(productId).orElseThrow();
    if (product.getStock() <= 0) {
        throw new RuntimeException("库存不足");
    }
    
    // 2. 扣减库存（行锁）
    int updated = productRepository.deductStock(productId, 1);
    if (updated == 0) {
        throw new RuntimeException("扣减库存失败");
    }
    
    // 3. 创建订单（不需要查询历史订单）
    Order order = new Order();
    order.setUserId(userId);
    order.setProductId(productId);
    orderRepository.save(order);
}

效果：
- 死锁率从15% -> 0%
- 订单创建耗时从800ms -> 50ms
- TPS提升10倍
```

---

### 2. 性能优化经验

**案例：批量更新性能优化**

```java
/**
 * 场景：每天凌晨批量更新100万用户的积分
 * 
 * ❌ 错误方案：逐条更新
 */
@Transactional
public void updatePointsBad() {
    List<User> users = userRepository.findAll(); // 100万用户
    
    for (User user : users) {
        // 每次都加行锁，非常慢！
        user.setPoints(user.getPoints() + 10);
        userRepository.save(user);
    }
    // 耗时：2小时
}

/**
 * ✅ 优化方案1：批量更新
 */
@Transactional
public void updatePointsGood1() {
    // 一条SQL更新所有用户
    int updated = entityManager.createQuery(
        "UPDATE User u SET u.points = u.points + 10"
    ).executeUpdate();
    
    log.info("批量更新{}条记录", updated);
    // 耗时：2分钟
}

/**
 * ✅ 优化方案2：分批处理（避免长事务）
 */
public void updatePointsGood2() {
    int batchSize = 10000;
    int offset = 0;
    
    while (true) {
        // 每次处理1万条
        int updated = updateBatch(offset, batchSize);
        
        if (updated == 0) break;
        
        offset += batchSize;
        log.info("已处理{}条记录", offset);
        
        // 每批之间休息100ms，避免压垮数据库
        Thread.sleep(100);
    }
    // 耗时：5分钟，但不会阻塞其他事务
}

@Transactional
public int updateBatch(int offset, int limit) {
    return entityManager.createQuery(
        "UPDATE User u SET u.points = u.points + 10 " +
        "WHERE u.id IN (SELECT u2.id FROM User u2 ORDER BY u2.id LIMIT :limit OFFSET :offset)"
    )
    .setParameter("limit", limit)
    .setParameter("offset", offset)
    .executeUpdate();
}
```

---

### 3. 面试高频问题 + 标准答案

**Q1: SELECT ... FOR UPDATE 和 SELECT ... LOCK IN SHARE MODE 的区别？**

```
A: 
1. FOR UPDATE（排他锁）：
   - 完全锁定记录，其他事务不能读（加锁读）也不能写
   - 用于：即将修改数据的场景
   - 示例：扣减库存

2. LOCK IN SHARE MODE（共享锁）：
   - 锁定记录，但允许其他事务读（加锁读），不允许写
   - 用于：需要保证读取的数据不被修改的场景
   - 示例：计算订单总金额时，确保商品价格不变

3. 实战建议：
   - 90%场景用FOR UPDATE（更安全）
   - 只有明确需要"读读不阻塞"时才用LOCK IN SHARE MODE
```

**Q2: REPEATABLE READ能完全避免幻读吗？**

```
A: 不能完全避免，取决于查询方式：

1. 快照读（普通SELECT）：
   SELECT * FROM t WHERE id > 10;
   - 使用MVCC，读取快照版本
   - 不会看到其他事务插入的新数据
   - ✅ 避免了幻读

2. 当前读（加锁SELECT）：
   SELECT * FROM t WHERE id > 10 FOR UPDATE;
   - 加临键锁，锁定(10, +∞)范围
   - 阻止其他事务插入数据
   - ✅ 避免了幻读

3. 但是，如果先快照读，再当前读：
   T1: SELECT * FROM t WHERE id > 10;         // 快照读，看到10条
   T2: INSERT INTO t VALUES (15, 'xxx');      // 其他事务插入
   T2: COMMIT;
   T1: SELECT * FROM t WHERE id > 10 FOR UPDATE; // 当前读，看到11条
   - ❌ 出现幻读！

结论：
- RR级别在单次查询内能避免幻读
- 但在同一事务的多次查询间，可能出现幻读
- 要完全避免幻读，使用SERIALIZABLE级别
```

**Q3: 如何诊断线上的死锁问题？**

```
A: 5步诊断法：

1. 查看死锁日志：
   SHOW ENGINE INNODB STATUS;
   -- 找LATEST DETECTED DEADLOCK部分
   -- 记录哪两个事务死锁，锁的是哪些行

2. 分析事务执行顺序：
   SELECT * FROM information_schema.INNODB_TRX;
   -- 查看当前运行的事务

3. 检查应用日志：
   -- 找到业务代码中对应的SQL执行顺序

4. 复现死锁：
   -- 在测试环境按相同顺序执行SQL

5. 解决方案：
   a. 调整加锁顺序（最常用）
   b. 优化索引（减少锁范围）
   c. 缩短事务时间
   d. 降低隔离级别（慎用）

实战工具：
-- 开启死锁日志记录
SET GLOBAL innodb_print_all_deadlocks = ON;

-- 日志会写入错误日志文件
-- 每次死锁都会记录详细信息
```

---

## 🎖️ 加分项：你需要了解的前沿知识

### 1. MySQL 8.0的新特性

```sql
-- 1. 跳过锁等待（8.0.1+）
SELECT * FROM t WHERE id = 1 FOR UPDATE NOWAIT;
-- 如果行被锁定，立即返回错误，不等待

SELECT * FROM t WHERE id = 1 FOR UPDATE SKIP LOCKED;
-- 如果行被锁定，跳过这一行，继续查询其他行

-- 应用场景：任务队列
CREATE TABLE task_queue (
    id BIGINT PRIMARY KEY,
    status VARCHAR(20),
    ...
);

-- 多个worker并发获取任务，不会互相阻塞
SELECT * FROM task_queue 
WHERE status = 'PENDING' 
LIMIT 10 
FOR UPDATE SKIP LOCKED;
```

### 2. 乐观锁的性能对比

```
测试场景：1000个线程同时更新同一行

悲观锁（FOR UPDATE）：
- 平均响应时间：50ms
- 成功率：100%
- TPS：20

乐观锁（version）：
- 平均响应时间：5ms（首次）
- 成功率：1%（999次冲突）
- TPS：200（理论值，实际需重试）

结论：
- 冲突率低（<10%）：用乐观锁
- 冲突率高（>50%）：用悲观锁
- 混合策略：先乐观锁，失败后降级为悲观锁
```

---

## 🎬 面试表现建议

### 回答模板：

```
面试官：你们项目中怎么处理高并发下的库存扣减？

你的回答：
"我们的库存扣减经历了3个版本的优化：

【第一版】纯乐观锁（version）
- 优点：性能好，TPS达到500
- 问题：秒杀场景冲突率90%，大量用户请求失败

【第二版】改为悲观锁（FOR UPDATE）
- 优点：成功率100%
- 问题：TPS下降到50，响应慢

【第三版】Redis预扣减 + 异步数据库更新
- 流程：
  1. Redis原子扣减（DECR命令）
  2. 扣减成功则发MQ消息
  3. 消费者更新数据库（悲观锁）
  4. 如果数据库扣减失败，补偿Redis库存
  
- 效果：
  • TPS提升到2000
  • 用户响应时间<50ms
  • 数据最终一致（允许短暂不一致）

【监控告警】
- 设置Redis和数据库库存差异监控
- 差异>10%触发告警
- 定时对账任务（每小时）

这个方案在双11期间支撑了100万QPS，库存准确率99.99%。"

这样回答展示了：
✓ 技术演进思路
✓ 问题解决能力
✓ 实战经验
✓ 数据支撑
```

---

## 💼 项目经验包装建议

### 简历上怎么写：

**❌ 普通写法：**
```
负责订单系统开发，使用MySQL事务保证数据一致性
```

**✅ 加分写法：**
```
【订单系统性能优化】
- 问题：高并发下频繁死锁，订单创建失败率15%
- 分析：通过SHOW ENGINE INNODB STATUS定位到锁冲突点
- 方案：
  1. 统一加锁顺序，避免循环等待
  2. 优化SQL索引，将表锁降级为行锁
  3. 引入Redis分布式锁削峰
- 成果：死锁率降至0%，TPS提升10倍，P99延迟从800ms降至50ms

【库存扣减架构设计】
- 设计Redis+MySQL双层存储架构
- 使用乐观锁+悲观锁混合策略
- 实现最终一致性保证机制
- 支撑双11 100万QPS，超卖率<0.01%
```

---

## 🔬 深度测试用例（展示专业性）

我为你补充几个**高级测试场景**，运行这些测试并理解结果，面试时可以展示：

```java
/**
 * 场景8：索引失效导致的锁升级
 * 
 * 核心知识点：
 * 1. 没有命中索引会导致表锁
 * 2. 类型转换、函数调用会导致索引失效
 * 3. 如何通过EXPLAIN分析锁范围
 */
@Test
public void testLockEscalation() throws InterruptedException {
    log.info("========== 场景8：索引失效导致锁升级 ==========");
    
    // 准备数据：balance字段没有索引
    Account acc1 = new Account();
    acc1.setAccountNo("ACC001");
    acc1.setBalance(new BigDecimal("1000"));
    
    Account acc2 = new Account();
    acc2.setAccountNo("ACC002");
    acc2.setBalance(new BigDecimal("2000"));
    
    accountRepository.saveAll(Arrays.asList(acc1, acc2));
    
    CountDownLatch latch = new CountDownLatch(2);
    
    // 线程1：更新ACC001（使用无索引字段balance）
    new Thread(() -> {
        transactionTemplate.execute(status -> {
            log.info("[T1] 执行：UPDATE WHERE balance = 1000 (无索引!)");
            
            // 这条SQL会扫描全表，锁住所有行！
            entityManager.createQuery(
                "UPDATE Account a SET a.accountNo = 'LOCKED' " +
                "WHERE a.balance = 1000"
            ).executeUpdate();
            
            log.info("[T1] 更新完成，持有锁3秒...");
            
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            
            latch.countDown();
            return null;
        });
    }).start();
    
    Thread.sleep(500);
    
    // 线程2：尝试更新ACC002（不同的行！）
    new Thread(() -> {
        long startTime = System.currentTimeMillis();
        
        transactionTemplate.execute(status -> {
            log.info("[T2] 尝试更新ACC002 (使用有索引的accountNo)");
            
            Account acc = accountRepository
                .findByAccountNoWithExclusiveLock("ACC002")
                .orElseThrow();
            
            long waitTime = System.currentTimeMillis() - startTime;
            log.info("[T2] 获取锁成功，等待了{}ms", waitTime);
            log.info("[T2] 【重要】虽然更新的是不同行，但因为T1的表扫描锁，T2被阻塞！");
            
            acc.setBalance(new BigDecimal("2100"));
            accountRepository.save(acc);
            
            latch.countDown();
            return null;
        });
    }).start();
    
    latch.await(10, TimeUnit.SECONDS);
    
    log.info("========== 教训：一定要确保WHERE条件命中索引！ ==========");
}

/**
 * 场景9：MVCC快照读 vs 当前读
 * 
 * 核心知识点：
 * 1. 快照读：普通SELECT，读取快照版本
 * 2. 当前读：SELECT FOR UPDATE，读取最新版本并加锁
 * 3. 同一事务中混用可能导致数据不一致
 */
@Test
public void testSnapshotReadVsCurrentRead() throws InterruptedException {
    log.info("========== 场景9：快照读 vs 当前读 ==========");
    
    Account acc = new Account();
    acc.setAccountNo("ACC001");
    acc.setBalance(new BigDecimal("1000"));
    accountRepository.save(acc);
    
    CountDownLatch latch = new CountDownLatch(2);
    
    // 事务1：先快照读，再当前读
    new Thread(() -> {
        transactionTemplate.execute(status -> {
            log.info("[T1] 第一次查询（快照读）");
            Account snapshot1 = accountRepository
                .findByAccountNo("ACC001").orElseThrow();
            log.info("[T1] 快照读结果: balance={}", snapshot1.getBalance());
            
            try {
                Thread.sleep(2000); // 等待T2修改数据
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            
            log.info("[T1] 第二次查询（仍然是快照读）");
            Account snapshot2 = accountRepository
                .findByAccountNo("ACC001").orElseThrow();
            log.info("[T1] 快照读结果: balance={} (仍然是1000)", snapshot2.getBalance());
            log.info("[T1] 【MVCC保证】在同一事务中，快照读总是读到事务开始时的版本");
            
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            
            log.info("[T1] 第三次查询（当前读 FOR UPDATE）");
            Account current = accountRepository
                .findByAccountNoWithExclusiveLock("ACC001").orElseThrow();
            log.info("[T1] 当前读结果: balance={} (变成了1100!)", current.getBalance());
            log.info("[T1] 【注意】当前读读取的是最新提交的版本，与快照读不同！");
            
            latch.countDown();
            return null;
        });
    }).start();
    
    Thread.sleep(500);
    
    // 事务2：修改数据
    new Thread(() -> {
        transactionTemplate.execute(status -> {
            log.info("[T2] 开始修改数据");
            
            Account acc2 = accountRepository
                .findByAccountNoWithExclusiveLock("ACC001").orElseThrow();
            acc2.setBalance(new BigDecimal("1100"));
            accountRepository.save(acc2);
            
            log.info("[T2] 修改完成: 1000 -> 1100");
            
            latch.countDown();
            return null;
        });
    }).start();
    
    latch.await(10, TimeUnit.SECONDS);
    
    log.info("========== 总结：同一事务内，快照读和当前读看到的数据可能不同！ ==========");
}

/**
 * 场景10：间隙锁的边界情况
 * 
 * 核心知识点：
 * 1. 间隙锁的精确范围计算
 * 2. 唯一索引 vs 非唯一索引的锁行为差异
 * 3. 等值查询 vs 范围查询的锁范围
 */
@Test
public void testGapLockBoundary() throws InterruptedException {
    log.info("========== 场景10：间隙锁边界测试 ==========");
    
    // 准备数据：id = 10, 20, 30
    accountRepository.deleteAll();
    
    Account acc1 = new Account();
    acc1.setId(10L);
    acc1.setAccountNo("ACC010");
    acc1.setBalance(new BigDecimal("100"));
    
    Account acc2 = new Account();
    acc2.setId(20L);
    acc2.setAccountNo("ACC020");
    acc2.setBalance(new BigDecimal("200"));
    
    Account acc3 = new Account();
    acc3.setId(30L);
    acc3.setAccountNo("ACC030");
    acc3.setBalance(new BigDecimal("300"));
    
    accountRepository.saveAll(Arrays.asList(acc1, acc2, acc3));
    
    CountDownLatch latch = new CountDownLatch(4);
    
    // 事务1：锁定 id = 20
    new Thread(() -> {
        transactionTemplate.execute(status -> {
            log.info("[T1] SELECT * FROM account WHERE id = 20 FOR UPDATE");
            
            Account acc = entityManager.find(Account.class, 20L, LockModeType.PESSIMISTIC_WRITE);
            
            log.info("[T1] 锁定id=20，锁范围：");
            log.info("[T1]   - 记录锁：锁住id=20这一行");
            log.info("[T1]   - 间隙锁：锁住(10, 20)和(20, 30)两个间隙");
            log.info("[T1]   - 也就是说：不能在(10, 30)范围内插入数据");
            
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            
            latch.countDown();
            return null;
        });
    }).start();
    
    Thread.sleep(500);
    
    // 测试1：尝试插入id=15（在间隙内）
    new Thread(() -> {
        log.info("[T2] 尝试插入id=15 (在间隙(10,20)内)");
        long startTime = System.currentTimeMillis();
        
        try {
            transactionTemplate.execute(status -> {
                Account newAcc = new Account();
                newAcc.setId(15L);
                newAcc.setAccountNo("ACC015");
                newAcc.setBalance(new BigDecimal("150"));
                accountRepository.save(newAcc);
                
                long waitTime = System.currentTimeMillis() - startTime;
                log.info("[T2] 插入成功，等待了{}ms", waitTime);
                return null;
            });
        } catch (Exception e) {
            log.error("[T2] 插入失败（被间隙锁阻塞）");
        }
        
        latch.countDown();
    }).start();
    
    // 测试2：尝试插入id=25（在间隙内）
    new Thread(() -> {
        log.info("[T3] 尝试插入id=25 (在间隙(20,30)内)");
        long startTime = System.currentTimeMillis();
        
        try {
            transactionTemplate.execute(status -> {
                Account newAcc = new Account();
                newAcc.setId(25L);
                newAcc.setAccountNo("ACC025");
                newAcc.setBalance(new BigDecimal("250"));
                accountRepository.save(newAcc);
                
                long waitTime = System.currentTimeMillis() - startTime;
                log.info("[T3] 插入成功，等待了{}ms", waitTime);
                return null;
            });
        } catch (Exception e) {
            log.error("[T3] 插入失败（被间隙锁阻塞）");
        }
        
        latch.countDown();
    }).start();
    
    // 测试3：尝试插入id=35（在间隙外）
    new Thread(() -> {
        log.info("[T4] 尝试插入id=35 (在间隙外，30之后)");
        long startTime = System.currentTimeMillis();
        
        try {
            transactionTemplate.execute(status -> {
                Account newAcc = new Account();
                newAcc.setId(35L);
                newAcc.setAccountNo("ACC035");
                newAcc.setBalance(new BigDecimal("350"));
                accountRepository.save(newAcc);
                
                long waitTime = System.currentTimeMillis() - startTime;
                log.info("[T4] ✓ 插入成功，等待了{}ms（几乎无等待）", waitTime);
                log.info("[T4] 【结论】间隙锁不影响范围外的插入");
                return null;
            });
        } catch (Exception e) {
            log.error("[T4] 插入失败");
        }
        
        latch.countDown();
    }).start();
    
    latch.await(10, TimeUnit.SECONDS);
}

/**
 * 场景11：唯一索引的锁优化
 * 
 * 核心知识点：
 * 1. 唯一索引等值查询：只加记录锁，不加间隙锁
 * 2. 非唯一索引等值查询：加记录锁 + 间隙锁
 * 3. 性能差异巨大
 */
@Test
public void testUniqueIndexLock() throws InterruptedException {
    log.info("========== 场景11：唯一索引锁优化 ==========");
    
    CountDownLatch latch = new CountDownLatch(2);
    
    // 事务1：通过唯一索引（account_no）查询
    new Thread(() -> {
        transactionTemplate.execute(status -> {
            log.info("[T1] 通过唯一索引查询: WHERE account_no = 'ACC001'");
            
            Account acc = accountRepository
                .findByAccountNoWithExclusiveLock("ACC001")
                .orElseThrow();
            
            log.info("[T1] 锁类型：只有记录锁（Record Lock）");
            log.info("[T1] 原因：唯一索引能精确定位到一行，不需要间隙锁");
            log.info("[T1] 优势：其他事务可以插入account_no='ACC001.5'等数据");
            
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            
            latch.countDown();
            return null;
        });
    }).start();
    
    Thread.sleep(500);
    
    // 事务2：尝试插入相邻数据
    new Thread(() -> {
        log.info("[T2] 尝试插入account_no='ACC001B'");
        long startTime = System.currentTimeMillis();
        
        try {
            transactionTemplate.execute(status -> {
                Account newAcc = new Account();
                newAcc.setAccountNo("ACC001B");
                newAcc.setBalance(new BigDecimal("500"));
                accountRepository.save(newAcc);
                
                long waitTime = System.currentTimeMillis() - startTime;
                log.info("[T2] ✓ 插入成功，等待了{}ms（几乎无等待）", waitTime);
                log.info("[T2] 【对比】如果是非唯一索引，这里会被间隙锁阻塞！");
                return null;
            });
        } catch (Exception e) {
            log.error("[T2] 插入失败");
        }
        
        latch.countDown();
    }).start();
    
    latch.await(10, TimeUnit.SECONDS);
}

/**
 * 场景12：混合使用乐观锁和悲观锁
 * 
 * 实战场景：
 * - 查询时用乐观锁（快）
 * - 如果冲突，降级为悲观锁（稳）
 * - 兼顾性能和成功率
 */
@Test
public void testHybridLockStrategy() throws InterruptedException {
    log.info("========== 场景12：混合锁策略 ==========");
    
    // 模拟100个并发请求
    int threadCount = 100;
    CountDownLatch latch = new CountDownLatch(threadCount);
    AtomicInteger optimisticSuccess = new AtomicInteger(0);
    AtomicInteger pessimisticSuccess = new AtomicInteger(0);
    
    for (int i = 0; i < threadCount; i++) {
        final int threadId = i;
        
        new Thread(() -> {
            try {
                boolean success = updateWithHybridLock("ACC001", 
                    new BigDecimal("1"), threadId);
                
                if (success) {
                    log.debug("[Thread-{}] 更新成功", threadId);
                }
            } catch (Exception e) {
                log.error("[Thread-{}] 更新失败", threadId, e);
            } finally {
                latch.countDown();
            }
        }).start();
    }
    
    latch.await(30, TimeUnit.SECONDS);
    
    log.info("========== 统计结果 ==========");
    log.info("乐观锁成功次数: {}", optimisticSuccess.get());
    log.info("悲观锁成功次数: {}", pessimisticSuccess.get());
    log.info("总成功次数: {}", optimisticSuccess.get() + pessimisticSuccess.get());
}

/**
 * 混合锁策略实现
 */
public boolean updateWithHybridLock(String accountNo, BigDecimal amount, int threadId) {
    int maxRetries = 3;
    
    // 第一步：尝试乐观锁（快速路径）
    for (int i = 0; i < maxRetries; i++) {
        try {
            return transactionTemplate.execute(status -> {
                Account acc = accountRepository.findByAccountNo(accountNo).orElseThrow();
                
                // 读取时不加锁
                BigDecimal newBalance = acc.getBalance().add(amount);
                acc.setBalance(newBalance);
                
                // JPA会检查version，冲突时抛异常
                accountRepository.save(acc);
                
                log.debug("[Thread-{}] 乐观锁成功（第{}次尝试）", threadId, i + 1);
                return true;
            });
            
        } catch (OptimisticLockException e) {
            log.debug("[Thread-{}] 乐观锁冲突（第{}次尝试）", threadId, i + 1);
            
            if (i < maxRetries - 1) {
                // 短暂休息后重试
                try {
                    Thread.sleep(new Random().nextInt(10));
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }
    
    // 第二步：乐观锁失败后，降级为悲观锁（保底策略）
    log.debug("[Thread-{}] 降级为悲观锁", threadId);
    
    return transactionTemplate.execute(status -> {
        // 使用悲观锁，100%成功
        Account acc = accountRepository
            .findByAccountNoWithExclusiveLock(accountNo)
            .orElseThrow();
        
        BigDecimal newBalance = acc.getBalance().add(amount);
        acc.setBalance(newBalance);
        accountRepository.save(acc);
        
        log.debug("[Thread-{}] 悲观锁成功", threadId);
        return true;
    });
}

/**
 * 场景13：分布式场景下的数据库锁
 * 
 * 问题：多个应用实例竞争同一资源
 * 方案：数据库实现分布式锁
 */
@Test
public void testDatabaseDistributedLock() throws InterruptedException {
    log.info("========== 场景13：数据库分布式锁 ==========");
    
    // 模拟3个应用实例
    int instanceCount = 3;
    CountDownLatch latch = new CountDownLatch(instanceCount);
    
    for (int i = 0; i < instanceCount; i++) {
        final String instanceId = "Instance-" + i;
        
        new Thread(() -> {
            try {
                executeWithDistributedLock("TASK_DAILY_REPORT", instanceId, () -> {
                    log.info("[{}] 开始执行定时任务", instanceId);
                    Thread.sleep(2000);
                    log.info("[{}] 定时任务执行完成", instanceId);
                });
            } catch (Exception e) {
                log.error("[{}] 执行失败", instanceId, e);
            } finally {
                latch.countDown();
            }
        }).start();
    }
    
    latch.await(15, TimeUnit.SECONDS);
    log.info("========== 结论：只有一个实例成功执行，其他实例被阻塞 ==========");
}

/**
 * 数据库分布式锁实现
 */
public void executeWithDistributedLock(String lockName, String instanceId, 
                                        Runnable task) throws Exception {
    Boolean acquired = transactionTemplate.execute(status -> {
        try {
            // 尝试获取锁：INSERT一条唯一记录
            entityManager.createNativeQuery(
                "INSERT INTO distributed_lock (lock_name, lock_holder, lock_time) " +
                "VALUES (:lockName, :instanceId, NOW())"
            )
            .setParameter("lockName", lockName)
            .setParameter("instanceId", instanceId)
            .executeUpdate();
            
            log.info("[{}] ✓ 获取分布式锁成功", instanceId);
            return true;
            
        } catch (Exception e) {
            log.info("[{}] ✗ 获取分布式锁失败（其他实例持有）", instanceId);
            return false;
        }
    });
    
    if (Boolean.TRUE.equals(acquired)) {
        try {
            // 执行业务逻辑
            task.run();
            
        } finally {
            // 释放锁：DELETE记录
            transactionTemplate.execute(status -> {
                entityManager.createNativeQuery(
                    "DELETE FROM distributed_lock WHERE lock_name = :lockName"
                )
                .setParameter("lockName", lockName)
                .executeUpdate();
                
                log.info("[{}] 释放分布式锁", instanceId);
                return null;
            });
        }
    }
}
```

---

## 🎤 模拟面试对话

### 对话1：深挖技术细节

```
面试官：你刚才提到用FOR UPDATE解决写冲突，那你知道FOR UPDATE加的是什么类型的锁吗？

你：FOR UPDATE加的是排他锁（X锁），具体来说：
1. 如果是主键或唯一索引的等值查询，只加记录锁
2. 如果是范围查询或非唯一索引，会加临键锁（记录锁+间隙锁）
3. 如果没有命中索引，会锁全表

面试官：临键锁？能详细说说吗？

你：临键锁是InnoDB在RR隔离级别下防止幻读的关键机制。
举个例子（在白板上画图）：

假设表中有id=10, 20, 30三条记录
执行：SELECT * FROM t WHERE id > 15 FOR UPDATE

加锁范围：
(10, 20]  ← 临键锁：锁住间隙(10,20)和记录20
(20, 30]  ← 临键锁
(30, +∞)  ← 间隙锁

作用：
- 防止其他事务在(10, +∞)范围内插入数据
- 保证两次查询结果一致，避免幻读

面试官：那如果我就想锁id=20这一行，不想锁间隙怎么办？

你：有两种方案：
1. 使用RC隔离级别（READ COMMITTED）：
   SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
   这个级别下只加记录锁，不加间隙锁
   
2. 使用唯一索引等值查询：
   SELECT * FROM t WHERE id = 20 FOR UPDATE;
   等值查询主键时，只加记录锁
   
但要注意：RC级别会有幻读问题，需要根据业务场景权衡。

面试官：（点头）不错，那你们生产环境用的什么隔离级别？

你：我们用的是MySQL默认的REPEATABLE READ。
选择原因：
1. 主从复制更安全（statement格式）
2. 业务场景对幻读比较敏感
3. 性能和一致性的平衡点

但我们也做了优化：
1. 核心查询都加了合适的索引，避免全表扫描
2. 事务尽量短，减少锁持有时间
3. 统一加锁顺序，避免死锁
```

### 对话2：解决实际问题

```
面试官：假设线上突然出现大量死锁告警，你会怎么处理？

你：我会按以下步骤快速定位和解决：

【第一步】止血（5分钟内）
1. 查看监控大盘，确认影响范围
2. 如果是某个接口导致，先降级该接口
3. 如果是数据库整体问题，考虑切换到从库

【第二步】定位原因（10分钟内）
1. 执行 SHOW ENGINE INNODB STATUS
   找到 LATEST DETECTED DEADLOCK 部分
   
2. 分析死锁日志：
   *** (1) TRANSACTION:
   TRANSACTION 1234, ACTIVE 2 sec starting index read
   mysql tables in use 1, locked 1
   LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
   MySQL thread id 10, OS thread handle 140, query id 100
   UPDATE account SET balance = balance - 100 WHERE id = 1
   
   *** (2) TRANSACTION:
   TRANSACTION 1235, ACTIVE 1 sec starting index read
   mysql tables in use 1, locked 1
   2 lock struct(s), heap size 1136, 1 row lock(s)
   MySQL thread id 11, OS thread handle 141, query id 101
   UPDATE account SET balance = balance + 100 WHERE id = 2
   *** WE ROLL BACK TRANSACTION (2)
   
3. 结论：两个事务以不同顺序锁定id=1和id=2，形成循环等待

【第三步】临时方案（30分钟内）
1. 在应用层加分布式锁：
   String lockKey = Stream.of(id1, id2).sorted().collect(Collectors.joining(":"));
   redisLock.lock(lockKey);
   
2. 或者调整超时时间，让死锁更快被检测

【第四步】根本解决（2小时内）
1. 修改代码，统一加锁顺序：
   List<Long> ids = Arrays.asList(id1, id2);
   Collections.sort(ids);
   for (Long id : ids) {
       lockAccount(id);
   }
   
2. 灰度发布新版本
3. 观察监控，确认死锁消除

【第五步】复盘和预防
1. 写事故报告，分析根本原因
2. 添加单元测试，覆盖死锁场景
3. 完善监控告警，死锁率>1%立即告警
4. 团队分享，避免类似问题

面试官：如果死锁日志看不出明显规律呢？

你：这种情况说明死锁比较复杂，可能涉及多个表或多个事务。
我会：

1. 开启全量死锁日志：
   SET GLOBAL innodb_print_all_deadlocks = ON;
   收集更多案例

2. 使用MySQL Enterprise Monitor或Percona Toolkit：
   pt-deadlock-logger工具可以持续监控

3. 在测试环境复现：
   - 开启 general_log
   - 记录所有SQL执行顺序
   - 用多线程脚本模拟并发场景
   
4. 实在无法定位，考虑：
   - 降低隔离级别到RC（牺牲一致性换稳定性）